<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubelet on Je pense donc je suis</title>
    <link>https://wenfeng-gao.github.io/tags/kubelet/</link>
    <description>Recent content in Kubelet on Je pense donc je suis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>elricfeng@gmail.com (Wenfeng Gao)</managingEditor>
    <webMaster>elricfeng@gmail.com (Wenfeng Gao)</webMaster>
    <lastBuildDate>Thu, 28 Feb 2019 23:07:20 +0800</lastBuildDate>
    
	<atom:link href="https://wenfeng-gao.github.io/tags/kubelet/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kubernetes源码分析之VolumeManager</title>
      <link>https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/</link>
      <pubDate>Thu, 28 Feb 2019 23:07:20 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/</guid>
      <description>前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(...) (*Kubelet, error) { ... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes) ... return klet, nil }  /pkg/kubelet/volumemanager/volume_manager.go: 149 // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface.</description>
    </item>
    
    <item>
      <title>Kubernetes源码分析之PLEG</title>
      <link>https://wenfeng-gao.github.io/post/k8s-pleg-source-code-analysis/</link>
      <pubDate>Fri, 22 Feb 2019 10:55:09 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/k8s-pleg-source-code-analysis/</guid>
      <description>PLEG(Pod Lifecycle Event Generator)是kubelet的核心模块，理解pleg对理解kubelet的运行机制很有帮助。本文的源码分析基于v1.13.2版本。
 pleg的创建 和很多其他manager相同，pleg会在NewMainKubelet中创建。
func RunKubelet(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce bool) error { ... k, err := CreateAndInitKubelet(...) if err != nil { return fmt.Errorf(&amp;quot;failed to create kubelet: %v&amp;quot;, err) } ... }  cmd/kubelet/app/server.go
func CreateAndInitKubelet(...) (k kubelet.Bootstrap, err error) { ... k, err = kubelet.NewMainKubelet(...) if err != nil { return nil, err } k.BirthCry() k.StartGarbageCollection() return k, nil }  pkg/kubelet/kubelet.go
// NewMainKubelet instantiates a new Kubelet object along with all the required internal modules.</description>
    </item>
    
    <item>
      <title>Kubernetes源码分析之CPU Manager</title>
      <link>https://wenfeng-gao.github.io/post/k8s_cpumanager_source_code/</link>
      <pubDate>Wed, 28 Nov 2018 23:14:35 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/k8s_cpumanager_source_code/</guid>
      <description>背景 Kubelet默认使用CFS Quota/Share的方式来实现Pod的CPU层面约束，而对于cpuset的支持，通过很长一段时间的讨论（[Issue] Determine if we should support cpuset-cpus and cpuset-mem)后，最终通过CPU Manager来实现。
CPU Manager作为alpha版本从v1.8开始出现，自v1.10开始作为beta版本默认开启。
使用方式 v1.10版本前需要开启feature-gate。
--feature-gates=CPUManager=true  开启cpuset还需要一些cpumanager的参数设置
--cpu-manager-policy=static --cpu-manager-reconcile-period=10s / Optional, default same as `--node-status-update-frequency`  还需要设置cpu reservation，可以通过
--kube-reserved // or --system-reserved  源码分析 Start CPU Manager 在kubelet启动之时，cpuManager会被生成，并Start。此时，cpuManager已经获取了所在宿主机的cpu拓扑结构，并且另起goroutine每隔reconcilePeriod时间，对宿主机上所有的activePods做一次reconcile。
kubelet.go
// initializeModules will initialize internal modules that do not require the container runtime to be up. // Note that the modules here must not depend on modules that are not initialized here.</description>
    </item>
    
  </channel>
</rss>