<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Je pense donc je suis</title>
    <link>https://wenfeng-gao.github.io/tags/docker/</link>
    <description>Recent content in Docker on Je pense donc je suis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>elricfeng@gmail.com (Wenfeng Gao)</managingEditor>
    <webMaster>elricfeng@gmail.com (Wenfeng Gao)</webMaster>
    <lastBuildDate>Tue, 15 May 2018 18:24:30 +0800</lastBuildDate>
    
	<atom:link href="https://wenfeng-gao.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Core Dump File Size Limit in Docker</title>
      <link>https://wenfeng-gao.github.io/post/core-dump-file-size-limit-in-docker/</link>
      <pubDate>Tue, 15 May 2018 18:24:30 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/core-dump-file-size-limit-in-docker/</guid>
      <description>Background 工作中遇到这样一个问题，运行环境为Docker容器，由于设置了容器的磁盘大小，但是没有设置core dump file的大小（默认为unlimited），当程序收到SIGABRT信号退出时，磁盘容易被撑满。
所以决定不让其产生core dump file。那么问题来了，在Docker容器环境下，该如何实现？
以下记录了围绕这个目的所做的一些尝试与遇到的问题。
Try and try Method 1: 使用systemd [failed] Systemd&amp;rsquo;s default behavior is to generate core dumps for all processes in /var/lib/systemd/coredump. This behavior can be overridden by creating a configuration snippet in the /etc/systemd/coredump.conf.d/ directory with the following content.
/etc/systemd/coredump.conf.d/custom.conf [Coredump] Storage=none  然后重载systemd的配置
systemctl daemon-reload  但是，结果是我们会得到一个诸如Failed to get D-Bus connection: Operation not permitted的error。根据14年的issue Failed to get D-Bus connection: No connection to service manager - CentOS 7 #7459，我们并不能在容器中直接使用systemctl，而是需要用我们自己的process manager（supervisor）来管理进程。</description>
    </item>
    
    <item>
      <title>Kubernetes on Coreos</title>
      <link>https://wenfeng-gao.github.io/post/kubernetes-on-coreos/</link>
      <pubDate>Tue, 13 Jun 2017 18:22:48 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/kubernetes-on-coreos/</guid>
      <description>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.
 I just follow the guide of CoreOS + Kubernetes Step By Step to deploy Kubernetes cluster on CoreOS.
Although this guide is detailed, there&amp;rsquo;s still something that will cause misunderstanding and should be paid close attention to. So this post is to help you better follow the guide and setup Kubernetes.
First of all, according to CoreOS cluster architectures, the CoreOS + Kubernetes Step By Step guide is for Easy development/testing cluster or Production cluster with central services, however, what I have is a Small cluster which was set up in the way Setup CoreOS Cluster with Static IPs, that will make some difference to ETCD_ENDPOINTS environment variable.</description>
    </item>
    
    <item>
      <title>Setup Coreos Cluster With Static Ip</title>
      <link>https://wenfeng-gao.github.io/post/setup-coreos-cluster-with-static-ip/</link>
      <pubDate>Thu, 08 Jun 2017 18:22:33 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/setup-coreos-cluster-with-static-ip/</guid>
      <description>We have talked about how to setup a CoreOS cluster in my previous post: Setup CoreOS Cluster Manually with VirtualBox. However, as we setup the cluster in VirtualBox, which uses DHCP as default, the etcd2 may not work when VM&amp;rsquo;s IP changed.
So in this article I&amp;rsquo;ll tell you how to upgrade your cluster and enable the VMs use static IPs instead of DHCP.
Setup Static IP First of all, make sure your cluster node VM uses the bridge connection type (as default), that will enable the connection between outer world, as we are not going to set IP tables.</description>
    </item>
    
    <item>
      <title>Mesos Checkpoint Feature &amp; Master Agent Connection</title>
      <link>https://wenfeng-gao.github.io/post/mesos_checkpoint_feature/</link>
      <pubDate>Thu, 18 May 2017 09:56:49 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/mesos_checkpoint_feature/</guid>
      <description>Mesos在更新版本后将slave改名为agent，所以本文中的agent与mesos-slave完全等同。
本文将讨论的问题：
 Mesos checkpoint 机制的作用 Mesos master 与 agent连接检查的机制 Mesos master 与 agent连接断开后的状态变化  Usage of Mesos Checkpoint Feature Mesos的checkpoint功能主要能起到3个作用：
Agent disconnect with executor  当agent线程挂掉，或者与executor无法连接时，如果framework没有使用checkpoint，executor一旦发现与agent断开，立即自动退出。 如果framework使用了checkpoint，executor将在一段时间内（MESOS_RECOVERY_TIMEOUT）尝试重连，超出timeout之后才会自动退出。这个时间的设置可以通过--recovery_timeout标签来设置，默认15分钟。  Agent disconnect with master  当agent线程挂掉，或者与master连接断开时，如果没有checkpoint，master会立即为此agent管理的所有task发送TASK_LOST状态变更的信息，然后等待一段时间，给agent重连的机会（这段时间为mesos health check的时间，可以通过--agent_ping_timeout 和 --max_agent_ping_timeouts标签来设置），如果agent重连成功，master会kill掉之前发送TASK_LOST的所有task。 如果使用了checkpoint，master不会发送TASK_LOST，而是直接等待，如果重连成功了，也不会kill任何task，就像什么也没有发生一样。  Agent recovery  当agent重启后，如果没有checkpoint，agent管理的还存活着的task会被立即重启。 如果使用了checkpoint，agent会将一些信息（Task Info, Executor Info, etc.）写入本地磁盘，重启后可以根据设置来进行恢复。 这些设置有3个：  strict: 若为true，恢复时出现的所有error将被视为fatal，恢复中断；若为false，忽略所有error，以最大的可能去恢复；默认为true。 recover：若为reconnect，重连所有存活的executor；若为cleanup，kill所有存活的executor并退出；默认为reconnect。 recovery_timeout，前面也有所提到，这是给agent预留的恢复时间，如果超过这个时间后还有executor没有连到，那么那些executor将会自动退出，默认时间为15分钟。   Dealing with Partitioned or Failed Agents 2 mechanisms to track availability and health Mesos master用两种方法来检测跟踪agent的可靠性：</description>
    </item>
    
    <item>
      <title>Deploy Worldpress in Coreos Cluster Using Fleet</title>
      <link>https://wenfeng-gao.github.io/post/deploy-worldpress-in-coreos-cluster-using-fleet/</link>
      <pubDate>Fri, 03 Jun 2016 18:22:13 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/deploy-worldpress-in-coreos-cluster-using-fleet/</guid>
      <description>In this post, I would like to tell you how to deploy a simple WorldPress service with MySQL database in CoreOS cluster in 3 minutes. You may reference my previous blog to setup a CoreOS cluster locally if you don&amp;rsquo;t have one.
Ok, ssh to one of your cluster node, let&amp;rsquo;s start.
Step 1 Create MySQL service Create a unit file mysql.service
[Unit] Description=MySQL DataBase After=etcd.service After=docker.service [Service] TimeoutStartSec=0 ExecStartPre=-/usr/bin/docker kill mysql ExecStartPre=-/usr/bin/docker rm mysql ExecStartPre=/usr/bin/docker pull mysql:5.</description>
    </item>
    
    <item>
      <title>Setup Coreos Cluster Manually with Virtualbox</title>
      <link>https://wenfeng-gao.github.io/post/setup-coreos-cluster-in-virtualbox/</link>
      <pubDate>Mon, 30 May 2016 18:21:53 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/setup-coreos-cluster-in-virtualbox/</guid>
      <description>Recently, I wanted to set up a tiny CoreOS cluster in my laptop, the good news is that with several commands and the existed Vagrantfile offered by the CoreOS official guide, we can setup a cluster in minutes; the bad news is that I don&amp;rsquo;t like everything perfectly done by Vagrant like a magic box, I want to do it total manually, and there&amp;rsquo;s no tutorial as I expected.</description>
    </item>
    
    <item>
      <title>浅谈Docker Bridge网络模式</title>
      <link>https://wenfeng-gao.github.io/post/docker-bridge-network/</link>
      <pubDate>Fri, 20 May 2016 18:21:36 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/docker-bridge-network/</guid>
      <description>本文将简单介绍一下Docker的3中网络模式，然后着重介绍bridge模式的数据传输过程，浅谈Docker容器与宿主机 之间，以及与外部世界的数据传输过程。
Docker的3种网络模式 我们知道，当Docker Daemon启动时，会创建3种网络模式供Docker容器使用：bridge, host 和none模式。 可以通过 docker network ls 看到如下结果
docker@master:~$ docker network ls NETWORK ID NAME DRIVER 9b7805f760e7 bridge bridge 77a7c8decdc1 host host 8a9285d7055e none null  其中none 将容器加入到一个没有网络接口的特殊网络栈，进入使用none网络的容器执行ifconfig会看到
root@0cb243cd1293:/# ifconfig lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:0 (0.</description>
    </item>
    
    <item>
      <title>Setup Jekyll in Windows environment using Docker</title>
      <link>https://wenfeng-gao.github.io/post/setup-jekyll-with-docker/</link>
      <pubDate>Thu, 12 May 2016 18:20:55 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/setup-jekyll-with-docker/</guid>
      <description>Github provides a great service for technique bloggers: Github Pages. Just by creating a repo in GitHub, we can host a domain like http://username.github.io. And with Jekyll we can write blogs with Markdown and preview blog pages locally and conveniently.
The problem for me is that my work environment is Windows, and it&amp;rsquo;s not easy to install Jekyll in Windows(especially in China). So an idea comes out with me is to use Docker.</description>
    </item>
    
  </channel>
</rss>