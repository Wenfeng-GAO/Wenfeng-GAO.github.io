<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on Je pense donc je suis</title>
    <link>https://wenfeng-gao.github.io/tags/shell/</link>
    <description>Recent content in Shell on Je pense donc je suis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>elricfeng@gmail.com (Wenfeng Gao)</managingEditor>
    <webMaster>elricfeng@gmail.com (Wenfeng Gao)</webMaster>
    <lastBuildDate>Thu, 28 Sep 2017 18:23:26 +0800</lastBuildDate>
    
	<atom:link href="https://wenfeng-gao.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Simple Commit-Msg for Git Hook</title>
      <link>https://wenfeng-gao.github.io/post/simple-commit-msg-hook/</link>
      <pubDate>Thu, 28 Sep 2017 18:23:26 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/simple-commit-msg-hook/</guid>
      <description>Although I am the only contributor of my own Github project, I still want my commit message to be tidier.
I wish all the commit messages will follow the pattern like:
[Example]: This is an Example. [Exercise]: This ia an Exercise. [Problem]: A problem solved. [Other]: Maybe a merge commit.  However, I usually remember to follow this pattern after the commit, that&amp;rsquo;s really disappointed. So I decided to write a simple hook to prevent this kind of Amnesia.</description>
    </item>
    
    <item>
      <title>Basic Shell Commands</title>
      <link>https://wenfeng-gao.github.io/post/basic-shell-commands/</link>
      <pubDate>Sat, 29 Jul 2017 18:23:09 +0800</pubDate>
      <author>elricfeng@gmail.com (Wenfeng Gao)</author>
      <guid>https://wenfeng-gao.github.io/post/basic-shell-commands/</guid>
      <description> 公司某个产品的测试环境比较复杂，它需要在 OpenStack 上创建3个节点，其中2个节点安装产品并实现高可用(HA)，第3个节点（TestAgent节点）与产品节点通过接收与发送数据包进行测试。
整个部署与测试流程都需要用Jenkins做自动化测试，而我的任务是将TestAgent节点移植到Docker容器中。用时一个多月，从熟悉源代码的部署与测试流程，到OpenStack的UI界面和CLI命令的基本使用，到OpenStack网络通信的基本理解，到Python的学习与使用(如使用pexpect通过ssh执行shell命令和脚本)， 到shell脚本的熟悉与使用，这个过程中爬过了许多大大小小的坑，也收获了很多东西，这里主要总结一下shell脚本的常用命令。
if if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi
其中TEST-COMMANDS一般有3种情形：
 shell command 如果它的返回状态为0，则执行CONSEQUENT-COMMANDS bracket [] double bracket [[]] 在方括号内都会做一些判断，如判断文件是否存在，[ -f FILE ]等等，而其两者的区别在于[[]]是[]的拓展，只支持与bash、zsh等几种shell，所以可移植性要差一些，不过如果不考虑移植性的问题，[[]]会更加简洁与可读，具体可以参考 StackOverFlow上的回答以及这篇文档。  有时简单的逻辑关系可以直接使用&amp;amp;&amp;amp;代替。
grep grep -rl “pattern” file 返回含有“pattern”的文件名，grep常与awk或者cut一起使用，例如
 grep &amp;quot;foo&amp;quot; file.txt | awk &#39;{print $1}&#39; grep &amp;quot;/bin/bash&amp;quot; /etc/passwd | cut -d&#39;:&#39; -f1,6  sed  sed -i &#39;pattern&#39; file 直接操作文件的内容而不是stdout sed &#39;s/hello/bonjour/&#39; greetings.txt 基本用法 sed &#39;/is beautiful/i Life&#39; input 在之前插入一行 sed &#39;/Hello/a World&#39; input 在之后增加一行 sed &#39;/^\s*$/d&#39; 删除空白行  echo with color  RED=&#39;\033[0;31m&#39; NC=&#39;\033[0m&#39; # No Color echo -e &amp;quot;I ${RED}love${NC} Stack Overflow\n&amp;quot;  </description>
    </item>
    
  </channel>
</rss>