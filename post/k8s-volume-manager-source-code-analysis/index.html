<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Kubernetes源码分析之VolumeManager - Je pense donc je suis</title>
  <meta property="og:title" content="Kubernetes源码分析之VolumeManager" />
  <meta name="twitter:title" content="Kubernetes源码分析之VolumeManager" />
  <meta name="description" content="前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(...) (*Kubelet, error) { ... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes) ... return klet, nil }  /pkg/kubelet/volumemanager/volume_manager.go: 149 // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface.">
  <meta property="og:description" content="前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(...) (*Kubelet, error) { ... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes) ... return klet, nil }  /pkg/kubelet/volumemanager/volume_manager.go: 149 // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface.">
  <meta name="twitter:description" content="前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet …">
  <meta name="author" content="Wenfeng Gao"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Je pense donc je suis",
    
    "url": "https://wenfeng-gao.github.io/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https://wenfeng-gao.github.io/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https://wenfeng-gao.github.io/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/",
          "name": "Kubernetes源码分析之 volume manager"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Wenfeng Gao"
  },
  "headline": "Kubernetes源码分析之VolumeManager",
  "description" : "前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(...) (*Kubelet, error) { ... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes) ... return klet, nil }  /pkg/kubelet/volumemanager/volume_manager.go: 149 // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface.",
  "inLanguage" : "en",
  "wordCount": 1274,
  "datePublished" : "2019-02-28T23:07:20",
  "dateModified" : "2019-02-28T23:07:20",
  "image" : "https://wenfeng-gao.github.io/img/avatar-icon.png",
  "keywords" : [ "k8s, kubelet" ],
  "mainEntityOfPage" : "https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https://wenfeng-gao.github.io/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https://wenfeng-gao.github.io/img/avatar-icon.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Kubernetes源码分析之VolumeManager" />
<meta property="og:description" content="前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(...) (*Kubelet, error) { ... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes) ... return klet, nil }  /pkg/kubelet/volumemanager/volume_manager.go: 149 // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface.">
<meta property="og:image" content="https://wenfeng-gao.github.io/img/avatar-icon.png" />
<meta property="og:url" content="https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Je pense donc je suis" />
  <meta name="twitter:title" content="Kubernetes源码分析之VolumeManager" />
  <meta name="twitter:description" content="前言 VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。 本文的分析基于v1.13.2版本。
正文 通很多其他manager一样，volumeManager在NewMainKubelet方法中生成。
pkg/kubelet/kubelet.go: 329 // NewMainKubelet …">
  <meta name="twitter:image" content="https://wenfeng-gao.github.io/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://wenfeng-gao.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://wenfeng-gao.github.io/img/avatar-icon.png" />
  <meta name="twitter:image" content="https://wenfeng-gao.github.io/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Je pense donc je suis" />

  <meta name="generator" content="Hugo 0.54.0" />
  <link rel="alternate" href="https://wenfeng-gao.github.io/index.xml" type="application/rss+xml" title="Je pense donc je suis">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://wenfeng-gao.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://wenfeng-gao.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://wenfeng-gao.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92434611-1', 'auto');
  ga('send', 'pageview');
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2394a408cca2a9e611801f76b5dc0267";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://wenfeng-gao.github.io/">Je pense donc je suis</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Blog" href="/">Blog</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/page/about/">About</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags">Tags</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Je pense donc je suis" href="https://wenfeng-gao.github.io/">
            <img class="avatar-img" src="https://wenfeng-gao.github.io/img/avatar-icon.png" alt="Je pense donc je suis" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Kubernetes源码分析之VolumeManager</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on February 28, 2019
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;6&nbsp;minutes
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1274&nbsp;words
  
  
    &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Wenfeng Gao
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h2 id="前言">前言</h2>

<p>VolumeManager是kubernetes负责管理pod存储相关的重要组件，理解VolumeManager是理解pod生命周期的重要环节。
本文的分析基于v1.13.2版本。</p>

<h2 id="正文">正文</h2>

<p>通很多其他manager一样，<code>volumeManager</code>在<code>NewMainKubelet</code>方法中生成。</p>

<pre><code class="language-go">pkg/kubelet/kubelet.go: 329

// NewMainKubelet instantiates a new Kubelet object along with all the required internal modules.
// No initialization of Kubelet and its modules should happen here.
func NewMainKubelet(...) (*Kubelet, error) {
  ...
  // setup volumeManager
	klet.volumeManager = volumemanager.NewVolumeManager(
		kubeCfg.EnableControllerAttachDetach,
		nodeName,
		klet.podManager,
		klet.statusManager,
		klet.kubeClient,
		klet.volumePluginMgr,
		klet.containerRuntime,
		kubeDeps.Mounter,
		klet.getPodsDir(),
		kubeDeps.Recorder,
		experimentalCheckNodeCapabilitiesBeforeMount,
		keepTerminatedPodVolumes)
  ...
	return klet, nil
}
</code></pre>

<pre><code class="language-go">/pkg/kubelet/volumemanager/volume_manager.go: 149

// NewVolumeManager returns a new concrete instance implementing the
// VolumeManager interface.
//
// kubeClient - kubeClient is the kube API client used by DesiredStateOfWorldPopulator
//   to communicate with the API server to fetch PV and PVC objects
// volumePluginMgr - the volume plugin manager used to access volume plugins.
//   Must be pre-initialized.
func NewVolumeManager(
	controllerAttachDetachEnabled bool,
	nodeName k8stypes.NodeName,
	podManager pod.Manager,
	podStatusProvider status.PodStatusProvider,
	kubeClient clientset.Interface,
	volumePluginMgr *volume.VolumePluginMgr,
	kubeContainerRuntime container.Runtime,
	mounter mount.Interface,
	kubeletPodsDir string,
	recorder record.EventRecorder,
	checkNodeCapabilitiesBeforeMount bool,
	keepTerminatedPodVolumes bool) VolumeManager {

	vm := &amp;volumeManager{
		kubeClient:          kubeClient,
		volumePluginMgr:     volumePluginMgr,
		desiredStateOfWorld: cache.NewDesiredStateOfWorld(volumePluginMgr),
		actualStateOfWorld:  cache.NewActualStateOfWorld(nodeName, volumePluginMgr),
		operationExecutor: operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(
			kubeClient,
			volumePluginMgr,
			recorder,
			checkNodeCapabilitiesBeforeMount,
			volumepathhandler.NewBlockVolumePathHandler())),
	}

	vm.desiredStateOfWorldPopulator = populator.NewDesiredStateOfWorldPopulator(
		kubeClient,
		desiredStateOfWorldPopulatorLoopSleepPeriod,
		desiredStateOfWorldPopulatorGetPodStatusRetryDuration,
		podManager,
		podStatusProvider,
		vm.desiredStateOfWorld,
		vm.actualStateOfWorld,
		kubeContainerRuntime,
		keepTerminatedPodVolumes)
	vm.reconciler = reconciler.NewReconciler(
		kubeClient,
		controllerAttachDetachEnabled,
		reconcilerLoopSleepPeriod,
		reconcilerSyncStatesSleepPeriod,
		waitForAttachTimeout,
		nodeName,
		vm.desiredStateOfWorld,
		vm.actualStateOfWorld,
		vm.desiredStateOfWorldPopulator.HasAddedPods,
		vm.operationExecutor,
		mounter,
		volumePluginMgr,
		kubeletPodsDir)

	return vm
}
</code></pre>

<p>在kubelet <code>Run</code>方法中会启动<code>volumeManager</code>。</p>

<pre><code class="language-go">/pkg/kubelet/kubelet.go: 1407

// Run starts the kubelet reacting to config updates
func (kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate) {
	...

	// Start volume manager
	go kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)

	...

	// Start the pod lifecycle event generator.
	kl.pleg.Start()
	kl.syncLoop(updates, kl)
}
</code></pre>

<p><code>volumeManager.Run</code>方法主要会用goroutine的方式执行2个重要的方法<code>desiredStateOfWorldPopulator.Run</code>和<code>reconciler.Run</code>。</p>

<pre><code class="language-go">/pkg/kubelet/volumemanager/volume_manager.go: 242

func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{}) {
	defer runtime.HandleCrash()

	go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)
	klog.V(2).Infof(&quot;The desired_state_of_world populator starts&quot;)

	klog.Infof(&quot;Starting Kubelet Volume Manager&quot;)
	go vm.reconciler.Run(stopCh)

	metrics.Register(vm.actualStateOfWorld, vm.desiredStateOfWorld, vm.volumePluginMgr)

	&lt;-stopCh
	klog.Infof(&quot;Shutting down Kubelet Volume Manager&quot;)
}
</code></pre>

<h3 id="desiredstateofworldpopulator">DesiredStateOfWorldPopulator</h3>

<p><code>DesiredStateOfWorldPopulator</code>遍历所有pod，确保有volume的pod都会存在在desired world cache中，或者将已经不存在的pod从cache中删除，保证cache的实时性。</p>

<pre><code class="language-go">/pkg/kubelet/volumemanager/populator/desired_state_of_world_populator.go: 128

func (dswp *desiredStateOfWorldPopulator) Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{}) {
	// Wait for the completion of a loop that started after sources are all ready, then set hasAddedPods accordingly
	klog.Infof(&quot;Desired state populator starts to run&quot;)
	wait.PollUntil(dswp.loopSleepDuration, func() (bool, error) {
		done := sourcesReady.AllReady()
		dswp.populatorLoop()
		return done, nil
	}, stopCh)
	dswp.hasAddedPodsLock.Lock()
	dswp.hasAddedPods = true
	dswp.hasAddedPodsLock.Unlock()
	wait.Until(dswp.populatorLoop, dswp.loopSleepDuration, stopCh)
}
</code></pre>

<pre><code class="language-go">/pkg/kubelet/volumemanager/populator/desired_state_of_world_populator.go: 153

func (dswp *desiredStateOfWorldPopulator) populatorLoop() {
	dswp.findAndAddNewPods()

	// findAndRemoveDeletedPods() calls out to the container runtime to
	// determine if the containers for a given pod are terminated. This is
	// an expensive operation, therefore we limit the rate that
	// findAndRemoveDeletedPods() is called independently of the main
	// populator loop.
	if time.Since(dswp.timeOfLastGetPodStatus) &lt; dswp.getPodStatusRetryDuration {
		klog.V(5).Infof(
			&quot;Skipping findAndRemoveDeletedPods(). Not permitted until %v (getPodStatusRetryDuration %v).&quot;,
			dswp.timeOfLastGetPodStatus.Add(dswp.getPodStatusRetryDuration),
			dswp.getPodStatusRetryDuration)

		return
	}

	dswp.findAndRemoveDeletedPods()
}
</code></pre>

<h2 id="reconciler">Reconciler</h2>

<p><code>Reconciler</code>会不断查看<code>actual state of the world</code>和<code>desired state of the world</code>是否一致，如果不一致，就通过<code>mount/unmount/attach/detach</code>等操作来保证一致.</p>

<pre><code class="language-go">/pkg/kubelet/volumemanager/reconciler/reconsiler.go: 142

func (rc *reconciler) Run(stopCh &lt;-chan struct{}) {
	wait.Until(rc.reconciliationLoopFunc(), rc.loopSleepDuration, stopCh)
}

func (rc *reconciler) reconciliationLoopFunc() func() {
	return func() {
		rc.reconcile()

		// Sync the state with the reality once after all existing pods are added to the desired state from all sources.
		// Otherwise, the reconstruct process may clean up pods' volumes that are still in use because
		// desired state of world does not contain a complete list of pods.
		if rc.populatorHasAddedPods() &amp;&amp; !rc.StatesHasBeenSynced() {
			klog.Infof(&quot;Reconciler: start to sync state&quot;)
			rc.sync()
		}
	}
}
</code></pre>

<p><code>reconciler</code>会保证*real world*与*desired world*的一致性。</p>

<pre><code class="language-go">/pkg/kubelet/volumemanager/reconciler/reconciler.go: 160

func (rc *reconciler) reconcile() {
	// Unmounts are triggered before mounts so that a volume that was
	// referenced by a pod that was deleted and is now referenced by another
	// pod is unmounted from the first pod before being mounted to the new
	// pod.

	// Ensure volumes that should be unmounted are unmounted.
	for _, mountedVolume := range rc.actualStateOfWorld.GetMountedVolumes() {
		if !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {
			// Volume is mounted, unmount it
			klog.V(5).Infof(mountedVolume.GenerateMsgDetailed(&quot;Starting operationExecutor.UnmountVolume&quot;, &quot;&quot;))
			err := rc.operationExecutor.UnmountVolume(
				mountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir)
			if err != nil &amp;&amp;
				!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
				!exponentialbackoff.IsExponentialBackoff(err) {
				// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
				// Log all other errors.
				klog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.UnmountVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
			}
			if err == nil {
				klog.Infof(mountedVolume.GenerateMsgDetailed(&quot;operationExecutor.UnmountVolume started&quot;, &quot;&quot;))
			}
		}
	}

	// Ensure volumes that should be attached/mounted are attached/mounted.
	for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() {
		volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)
		volumeToMount.DevicePath = devicePath
		if cache.IsVolumeNotAttachedError(err) {
			if rc.controllerAttachDetachEnabled || !volumeToMount.PluginIsAttachable {
				// Volume is not attached (or doesn't implement attacher), kubelet attach is disabled, wait
				// for controller to finish attaching volume.
				klog.V(5).Infof(volumeToMount.GenerateMsgDetailed(&quot;Starting operationExecutor.VerifyControllerAttachedVolume&quot;, &quot;&quot;))
				err := rc.operationExecutor.VerifyControllerAttachedVolume(
					volumeToMount.VolumeToMount,
					rc.nodeName,
					rc.actualStateOfWorld)
				if err != nil &amp;&amp;
					!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
					!exponentialbackoff.IsExponentialBackoff(err) {
					// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
					// Log all other errors.
					klog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.VerifyControllerAttachedVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
				}
				if err == nil {
					klog.Infof(volumeToMount.GenerateMsgDetailed(&quot;operationExecutor.VerifyControllerAttachedVolume started&quot;, &quot;&quot;))
				}
			} else {
				// Volume is not attached to node, kubelet attach is enabled, volume implements an attacher,
				// so attach it
				volumeToAttach := operationexecutor.VolumeToAttach{
					VolumeName: volumeToMount.VolumeName,
					VolumeSpec: volumeToMount.VolumeSpec,
					NodeName:   rc.nodeName,
				}
				klog.V(5).Infof(volumeToAttach.GenerateMsgDetailed(&quot;Starting operationExecutor.AttachVolume&quot;, &quot;&quot;))
				err := rc.operationExecutor.AttachVolume(volumeToAttach, rc.actualStateOfWorld)
				if err != nil &amp;&amp;
					!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
					!exponentialbackoff.IsExponentialBackoff(err) {
					// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
					// Log all other errors.
					klog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.AttachVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
				}
				if err == nil {
					klog.Infof(volumeToMount.GenerateMsgDetailed(&quot;operationExecutor.AttachVolume started&quot;, &quot;&quot;))
				}
			}
		} else if !volMounted || cache.IsRemountRequiredError(err) {
			// Volume is not mounted, or is already mounted, but requires remounting
			remountingLogStr := &quot;&quot;
			isRemount := cache.IsRemountRequiredError(err)
			if isRemount {
				remountingLogStr = &quot;Volume is already mounted to pod, but remount was requested.&quot;
			}
			klog.V(4).Infof(volumeToMount.GenerateMsgDetailed(&quot;Starting operationExecutor.MountVolume&quot;, remountingLogStr))
			err := rc.operationExecutor.MountVolume(
				rc.waitForAttachTimeout,
				volumeToMount.VolumeToMount,
				rc.actualStateOfWorld,
				isRemount)
			if err != nil &amp;&amp;
				!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
				!exponentialbackoff.IsExponentialBackoff(err) {
				// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
				// Log all other errors.
				klog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.MountVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
			}
			if err == nil {
				if remountingLogStr == &quot;&quot; {
					klog.V(1).Infof(volumeToMount.GenerateMsgDetailed(&quot;operationExecutor.MountVolume started&quot;, remountingLogStr))
				} else {
					klog.V(5).Infof(volumeToMount.GenerateMsgDetailed(&quot;operationExecutor.MountVolume started&quot;, remountingLogStr))
				}
			}
		} else if cache.IsFSResizeRequiredError(err) &amp;&amp;
			utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) {
			klog.V(4).Infof(volumeToMount.GenerateMsgDetailed(&quot;Starting operationExecutor.ExpandVolumeFSWithoutUnmounting&quot;, &quot;&quot;))
			err := rc.operationExecutor.ExpandVolumeFSWithoutUnmounting(
				volumeToMount.VolumeToMount,
				rc.actualStateOfWorld)
			if err != nil &amp;&amp;
				!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
				!exponentialbackoff.IsExponentialBackoff(err) {
				// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
				// Log all other errors.
				klog.Errorf(volumeToMount.GenerateErrorDetailed(&quot;operationExecutor.ExpandVolumeFSWithoutUnmounting failed&quot;, err).Error())
			}
			if err == nil {
				klog.V(4).Infof(volumeToMount.GenerateMsgDetailed(&quot;operationExecutor.ExpandVolumeFSWithoutUnmounting started&quot;, &quot;&quot;))
			}
		}
	}

	// Ensure devices that should be detached/unmounted are detached/unmounted.
	for _, attachedVolume := range rc.actualStateOfWorld.GetUnmountedVolumes() {
		// Check IsOperationPending to avoid marking a volume as detached if it's in the process of mounting.
		if !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &amp;&amp;
			!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) {
			if attachedVolume.GloballyMounted {
				// Volume is globally mounted to device, unmount it
				klog.V(5).Infof(attachedVolume.GenerateMsgDetailed(&quot;Starting operationExecutor.UnmountDevice&quot;, &quot;&quot;))
				err := rc.operationExecutor.UnmountDevice(
					attachedVolume.AttachedVolume, rc.actualStateOfWorld, rc.mounter)
				if err != nil &amp;&amp;
					!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
					!exponentialbackoff.IsExponentialBackoff(err) {
					// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
					// Log all other errors.
					klog.Errorf(attachedVolume.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.UnmountDevice failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
				}
				if err == nil {
					klog.Infof(attachedVolume.GenerateMsgDetailed(&quot;operationExecutor.UnmountDevice started&quot;, &quot;&quot;))
				}
			} else {
				// Volume is attached to node, detach it
				// Kubelet not responsible for detaching or this volume has a non-attachable volume plugin.
				if rc.controllerAttachDetachEnabled || !attachedVolume.PluginIsAttachable {
					rc.actualStateOfWorld.MarkVolumeAsDetached(attachedVolume.VolumeName, attachedVolume.NodeName)
					klog.Infof(attachedVolume.GenerateMsgDetailed(&quot;Volume detached&quot;, fmt.Sprintf(&quot;DevicePath %q&quot;, attachedVolume.DevicePath)))
				} else {
					// Only detach if kubelet detach is enabled
					klog.V(5).Infof(attachedVolume.GenerateMsgDetailed(&quot;Starting operationExecutor.DetachVolume&quot;, &quot;&quot;))
					err := rc.operationExecutor.DetachVolume(
						attachedVolume.AttachedVolume, false /* verifySafeToDetach */, rc.actualStateOfWorld)
					if err != nil &amp;&amp;
						!nestedpendingoperations.IsAlreadyExists(err) &amp;&amp;
						!exponentialbackoff.IsExponentialBackoff(err) {
						// Ignore nestedpendingoperations.IsAlreadyExists &amp;&amp; exponentialbackoff.IsExponentialBackoff errors, they are expected.
						// Log all other errors.
						klog.Errorf(attachedVolume.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.DetachVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error())
					}
					if err == nil {
						klog.Infof(attachedVolume.GenerateMsgDetailed(&quot;operationExecutor.DetachVolume started&quot;, &quot;&quot;))
					}
				}
			}
		}
	}
}
</code></pre>

<p><code>rc.sync()</code>只会执行1次，为了避免kubelet重启等行为期间有数据的不一致。它会扫描所有pod的volume目录，如果有不一致，将*actual world*和*desired world*的数据都补齐。</p>

<pre><code class="language-go">/pkg/kubelet/volumemanager/reconciler/reconciler.go: 328

// sync process tries to observe the real world by scanning all pods' volume directories from the disk.
// If the actual and desired state of worlds are not consistent with the observed world, it means that some
// mounted volumes are left out probably during kubelet restart. This process will reconstruct
// the volumes and update the actual and desired states. For the volumes that cannot support reconstruction,
// it will try to clean up the mount paths with operation executor.
func (rc *reconciler) sync() {
	defer rc.updateLastSyncTime()
	rc.syncStates()
}
</code></pre>

<h2 id="总结">总结</h2>

<p>VolumeManager是负责k8s存储的核心组件，它不但为其他组件提供存储方面的调用接口，同时也通过<code>desired world</code>、<code>actual world</code>、<code>reconciler</code>等机制，实现完整的、闭环的存储管理。</p>

<p>分析VolumeManager的相关代码，不但可以了解k8s的实现原理，还能对设计模式有所体悟和思考。</p>

<h2 id="ref">Ref</h2>

<ul>
<li><a href="https://blog.csdn.net/zhonglinzhang/article/details/82800287">https://blog.csdn.net/zhonglinzhang/article/details/82800287</a></li>
</ul>


        
          <div class="blog-tags">
            
              <a href="https://wenfeng-gao.github.io//tags/k8s/">k8s</a>&nbsp;
            
              <a href="https://wenfeng-gao.github.io//tags/kubelet/">kubelet</a>&nbsp;
            
          </div>
        

        

        
          
          
          <h4 class="see-also">See also</h4>
          <ul>
          
            <li><a href="/post/k8s-pleg-source-code-analysis/">Kubernetes源码分析之PLEG</a></li>
          
            <li><a href="/post/k8s_cpumanager_source_code/">Kubernetes源码分析之CPU Manager</a></li>
          
            <li><a href="/post/kubernetes-on-coreos/">Kubernetes on Coreos</a></li>
          
          </ul>
          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://wenfeng-gao.github.io/post/k8s-pleg-source-code-analysis/" data-toggle="tooltip" data-placement="top" title="Kubernetes源码分析之PLEG">&larr; Previous Post</a>
            </li>
          
          
        </ul>
      


      
        
          
          <div class="disqus-comments">                  
            <button id="show-comments" class="btn btn-default" type="button">Show <span class="disqus-comment-count" data-disqus-url="https://wenfeng-gao.github.io/post/k8s-volume-manager-source-code-analysis">comments</span></button>
            <div id="disqus_thread"></div>

            <script type="text/javascript">
              var disqus_config = function () {
              this.page.url = 'https:\/\/wenfeng-gao.github.io\/post\/k8s-volume-manager-source-code-analysis';
            };

          </script>
          </div>
          
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:elricfeng@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://plus.google.com/103999582027187063854" title="Google&#43;">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-google-plus fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/Wenfeng-GAO" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://stackoverflow.com/users/4262814/wenfeng" title="StackOverflow">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://paypal.me/elricfeng" title="PayPal">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-paypal fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            
            <a href="https://wenfeng-gao.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              Wenfeng Gao
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2019
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://wenfeng-gao.github.io/">Je pense donc je suis</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.54.0</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://wenfeng-gao.github.io/js/main.js"></script>
<script src="https://wenfeng-gao.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://wenfeng-gao.github.io/js/load-photoswipe.js"></script>







<script type="text/javascript">
$(function(){
  $('#show-comments').on('click', function(){
    var disqus_shortname = 'https-wenfeng-gao-github-io';
      
    (function() {
      var disqus = document.createElement('script'); 
      disqus.type = 'text/javascript'; 
      disqus.async = true;
      disqus.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(disqus);
    })();
      
    $(this).hide(); 
    });
  });
      
</script>
<script id="dsq-count-scr" src="//https-wenfeng-gao-github-io.disqus.com/count.js" async></script>




  </body>
</html>

